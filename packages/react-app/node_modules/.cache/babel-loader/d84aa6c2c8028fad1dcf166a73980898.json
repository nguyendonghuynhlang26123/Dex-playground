{"ast":null,"code":"import { utils } from 'ethers';\nimport { addressEqual } from './address';\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\nexport function encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId\n    };\n  } catch (_a) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\nexport function getUniqueCalls(requests) {\n  const unique = [];\n\n  for (const request of requests) {\n    if (!unique.find(x => addressEqual(x.address, request.address) && x.data === request.data && x.chainId === request.chainId)) {\n      unique.push(request);\n    }\n  }\n\n  return unique;\n}\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  const {\n    value,\n    success\n  } = result;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,QAAsB,QAAtB;AAIA,SAAS,YAAT,QAA6B,WAA7B;AAEA,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAA8C;AAClD,MAAI,CAAC,IAAL,EAAW;AACT;AACD;;AACD,QAAM;AAAE,IAAA,QAAF;AAAY,IAAA,MAAZ;AAAoB,IAAA;AAApB,MAA6B,IAAnC;AACA,EAAA,OAAO,CAAC,IAAR,CAAa,kCAAkC,QAAQ,CAAC,OAAO,WAAW,MAAM,SAAS,IAAI,EAA7F;AACD;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAA6C,OAA7C,EAA4D;AAChE,MAAI,CAAC,IAAL,EAAW;AACT,WAAO,SAAP;AACD;;AACD,QAAM;AAAE,IAAA,QAAF;AAAY,IAAA,MAAZ;AAAoB,IAAA;AAApB,MAA6B,IAAnC;;AACA,MAAI,CAAC,QAAQ,CAAC,OAAV,IAAqB,CAAC,MAA1B,EAAkC;AAChC,IAAA,iBAAiB,CAAC,IAAD,CAAjB;AACA,WAAO,SAAP;AACD;;AACD,MAAI;AACF,WAAO;AAAE,MAAA,OAAO,EAAE,QAAQ,CAAC,OAApB;AAA6B,MAAA,IAAI,EAAE,QAAQ,CAAC,SAAT,CAAmB,kBAAnB,CAAsC,MAAtC,EAA8C,IAA9C,CAAnC;AAAwF,MAAA;AAAxF,KAAP;AACD,GAFD,CAEE,OAAA,EAAA,EAAM;AACN,IAAA,iBAAiB,CAAC,IAAD,CAAjB;AACA,WAAO,SAAP;AACD;AACF;AAED,OAAM,SAAU,cAAV,CAAyB,QAAzB,EAA4C;AAChD,QAAM,MAAM,GAAc,EAA1B;;AACA,OAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC9B,QACE,CAAC,MAAM,CAAC,IAAP,CACE,CAAD,IAAO,YAAY,CAAC,CAAC,CAAC,OAAH,EAAY,OAAO,CAAC,OAApB,CAAZ,IAA4C,CAAC,CAAC,IAAF,KAAW,OAAO,CAAC,IAA/D,IAAuE,CAAC,CAAC,OAAF,KAAc,OAAO,CAAC,OADrG,CADH,EAIE;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,OAAZ;AACD;AACF;;AACD,SAAO,MAAP;AACD;AAUD,OAAM,SAAU,gBAAV,CACJ,IADI,EAEJ,MAFI,EAEiB;AAErB,MAAI,CAAC,MAAD,IAAW,CAAC,IAAhB,EAAsB;AACpB,WAAO,SAAP;AACD;;AACD,QAAM;AAAE,IAAA,KAAF;AAAS,IAAA;AAAT,MAAqB,MAA3B;;AACA,MAAI;AACF,QAAI,OAAJ,EAAa;AACX,aAAO;AACL,QAAA,KAAK,EAAE,IAAI,CAAC,QAAL,CAAc,SAAd,CAAwB,oBAAxB,CAA6C,IAAI,CAAC,MAAlD,EAA0D,KAA1D,CADF;AAIL,QAAA,KAAK,EAAE;AAJF,OAAP;AAMD,KAPD,MAOO;AACL,YAAM,YAAY,GAAW,IAAI,KAAK,CAAC,SAAV,CAAoB,CAAC,wBAAD,CAApB,EAAgD,kBAAhD,CAAmE,OAAnE,EAA4E,KAA5E,EAAmF,CAAnF,CAA7B;AACA,aAAO;AACL,QAAA,KAAK,EAAE,SADF;AAEL,QAAA,KAAK,EAAE,IAAI,KAAJ,CAAU,YAAV;AAFF,OAAP;AAID;AACF,GAfD,CAeE,OAAO,KAAP,EAAc;AACd,WAAO;AACL,MAAA,KAAK,EAAE,SADF;AAEL,MAAA,KAAK,EAAE;AAFF,KAAP;AAID;AACF","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\nimport { addressEqual } from './address';\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\nexport function encodeCallData(call, chainId) {\n    if (!call) {\n        return undefined;\n    }\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n    try {\n        return { address: contract.address, data: contract.interface.encodeFunctionData(method, args), chainId };\n    }\n    catch (_a) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n}\nexport function getUniqueCalls(requests) {\n    const unique = [];\n    for (const request of requests) {\n        if (!unique.find((x) => addressEqual(x.address, request.address) && x.data === request.data && x.chainId === request.chainId)) {\n            unique.push(request);\n        }\n    }\n    return unique;\n}\nexport function decodeCallResult(call, result) {\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}