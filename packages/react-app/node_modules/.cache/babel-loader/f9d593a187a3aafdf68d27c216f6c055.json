{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { callsReducer, chainStateReducer, getUniqueCalls, multicall as multicall1, multicall2, useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { useBlockNumbers } from '../../blockNumber/blockNumbers';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n\nexport function MultiChainStateProvider(_ref) {\n  let {\n    children,\n    multicallAddresses\n  } = _ref;\n  const {\n    multicallVersion\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const {\n    reportError\n  } = useNetwork();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const multicall = multicallVersion === 1 ? multicall1 : multicall2;\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = debouncedNetworks === networks ? getUniqueCalls(debouncedCalls) : []; // used for deep equality in hook dependencies\n\n  const uniqueCallsJSON = JSON.stringify(uniqueCalls);\n\n  function multicallForChain(chainId, provider) {\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n\n    const callsOnThisChain = uniqueCalls.filter(call => call.chainId === chainId);\n\n    if (callsOnThisChain.length === 0) {\n      return;\n    }\n\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      multicallForChain(Number(_chainId), provider);\n    }\n  }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/chainState/multiChainStates/provider.tsx"],"names":[],"mappings":";AAAA,SAAoB,SAApB,EAA+B,OAA/B,EAAwC,UAAxC,QAA0D,OAA1D;AACA,SAAS,eAAT,QAAgC,gBAAhC;AACA,SAAS,uBAAT,QAAwC,WAAxC;AACA,SACE,YADF,EAGE,iBAHF,EAIE,cAJF,EAKE,SAAS,IAAI,UALf,EAME,UANF,EAQE,SARF,EASE,UATF,QAUO,UAVP;AAWA,SAAS,mBAAT,QAAoC,eAApC;AACA,SAAS,eAAT,QAAgC,gCAAhC;AACA,SAAS,WAAT,QAA4B,8BAA5B;AACA,SAAS,gBAAT,QAAiC,4BAAjC;;AAWA,SAAS,iBAAT,CAA2B,QAA3B,EAAgD,KAAhD,EAA8D,kBAA9D,EAA6G;AAC3G,SAAO,WAAW,CAChB,MAAM,CAAC,IAAP,CAAY,QAAZ,EAAsB,GAAtB,CAA2B,OAAD,IAAa,CACrC,MAAM,CAAC,OAAD,CAD+B,EAErC;AACE,IAAA,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,OAAD,CAAP,CADd;AAEE,IAAA,gBAAgB,EAAE,kBAAkB,CAAC,MAAM,CAAC,OAAD,CAAP;AAFtC,GAFqC,CAAvC,CADgB,CAAlB;AASD;;AAED,OAAM,SAAU,uBAAV,OAAyE;AAAA,MAAvC;AAAE,IAAA,QAAF;AAAY,IAAA;AAAZ,GAAuC;AAC7E,QAAM;AAAE,IAAA;AAAF,MAAuB,SAAS,EAAtC;AACA,QAAM,QAAQ,GAAG,mBAAmB,EAApC;AACA,QAAM,YAAY,GAAG,eAAe,EAApC;AACA,QAAM;AAAE,IAAA;AAAF,MAAkB,UAAU,EAAlC;AAEA,QAAM,CAAC,KAAD,EAAQ,aAAR,IAAyB,UAAU,CAAC,YAAD,EAAe,EAAf,CAAzC;AACA,QAAM,CAAC,KAAD,EAAQ,aAAR,IAAyB,UAAU,CAAC,iBAAD,EAAoB,EAApB,CAAzC;AAEA,QAAM,SAAS,GAAG,gBAAgB,KAAK,CAArB,GAAyB,UAAzB,GAAsC,UAAxD;AAEA,QAAM,CAAC,cAAD,EAAiB,iBAAjB,IAAsC,eAAe,CAAC,KAAD,EAAQ,QAAR,EAAkB,EAAlB,CAA3D;AACA,QAAM,WAAW,GAAG,iBAAiB,KAAK,QAAtB,GAAiC,cAAc,CAAC,cAAD,CAA/C,GAAkE,EAAtF,CAZ6E,CAa7E;;AACA,QAAM,eAAe,GAAG,IAAI,CAAC,SAAL,CAAe,WAAf,CAAxB;;AAEA,WAAS,iBAAT,CAA2B,OAA3B,EAA6C,QAA7C,EAAuE;AACrE,UAAM,WAAW,GAAG,YAAY,CAAC,OAAD,CAAhC;AACA,UAAM,gBAAgB,GAAG,kBAAkB,CAAC,OAAD,CAA3C;;AAEA,QAAI,CAAC,QAAD,IAAa,CAAC,WAAlB,EAA+B;AAC7B;AACD;;AACD,QAAI,CAAC,gBAAL,EAAuB;AACrB,MAAA,WAAW,CAAC,IAAI,KAAJ,CAAU,0CAA0C,OAAO,EAA3D,CAAD,CAAX;AACA;AACD;;AACD,UAAM,gBAAgB,GAAG,WAAW,CAAC,MAAZ,CAAoB,IAAD,IAAU,IAAI,CAAC,OAAL,KAAiB,OAA9C,CAAzB;;AACA,QAAI,gBAAgB,CAAC,MAAjB,KAA4B,CAAhC,EAAmC;AACjC;AACD;;AACD,IAAA,gBAAgB,CACd,QADc,EAEd,SAFc,EAGd,gBAHc,EAId,WAJc,EAKd,gBALc,EAMd,aANc,EAOd,OAPc,EAQd,WARc,CAAhB;AAUD;;AAED,EAAA,SAAS,CAAC,MAAK;AACb,SAAK,MAAM,CAAC,QAAD,EAAW,QAAX,CAAX,IAAmC,MAAM,CAAC,OAAP,CAAe,QAAf,CAAnC,EAA6D;AAC3D,MAAA,iBAAiB,CAAC,MAAM,CAAC,QAAD,CAAP,EAAmB,QAAnB,CAAjB;AACD;AACF,GAJQ,EAIN,CAAC,YAAD,EAAe,QAAf,EAAyB,kBAAzB,EAA6C,eAA7C,CAJM,CAAT;AAMA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAM,iBAAiB,CAAC,QAAD,EAAW,KAAX,EAAkB,kBAAlB,CAAxB,EAA+D,CACnF,KADmF,EAEnF,kBAFmF,EAGnF,QAHmF,CAA/D,CAAtB;AAMA,QAAM,QAAQ,GAAG;AAAE,IAAA,MAAF;AAAU,IAAA;AAAV,GAAjB;AAEA,SAAO,IAAA,CAAC,uBAAuB,CAAC,QAAzB,EAAiC;AAAC,IAAA,KAAK,EAAE,QAAR;AAAkB,IAAA,QAAQ,EAAE;AAA5B,GAAjC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { callsReducer, chainStateReducer, getUniqueCalls, multicall as multicall1, multicall2, useConfig, useNetwork, } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { useBlockNumbers } from '../../blockNumber/blockNumbers';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nfunction composeChainState(networks, state, multicallAddresses) {\n    return fromEntries(Object.keys(networks).map((chainId) => [\n        Number(chainId),\n        {\n            value: state[Number(chainId)],\n            multicallAddress: multicallAddresses[Number(chainId)],\n        },\n    ]));\n}\nexport function MultiChainStateProvider({ children, multicallAddresses }) {\n    const { multicallVersion } = useConfig();\n    const networks = useReadonlyNetworks();\n    const blockNumbers = useBlockNumbers();\n    const { reportError } = useNetwork();\n    const [calls, dispatchCalls] = useReducer(callsReducer, []);\n    const [state, dispatchState] = useReducer(chainStateReducer, {});\n    const multicall = multicallVersion === 1 ? multicall1 : multicall2;\n    const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n    const uniqueCalls = debouncedNetworks === networks ? getUniqueCalls(debouncedCalls) : [];\n    // used for deep equality in hook dependencies\n    const uniqueCallsJSON = JSON.stringify(uniqueCalls);\n    function multicallForChain(chainId, provider) {\n        const blockNumber = blockNumbers[chainId];\n        const multicallAddress = multicallAddresses[chainId];\n        if (!provider || !blockNumber) {\n            return;\n        }\n        if (!multicallAddress) {\n            reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n            return;\n        }\n        const callsOnThisChain = uniqueCalls.filter((call) => call.chainId === chainId);\n        if (callsOnThisChain.length === 0) {\n            return;\n        }\n        performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    }\n    useEffect(() => {\n        for (const [_chainId, provider] of Object.entries(networks)) {\n            multicallForChain(Number(_chainId), provider);\n        }\n    }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n    const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n        state,\n        multicallAddresses,\n        networks,\n    ]);\n    const provided = { chains, dispatchCalls };\n    return _jsx(MultiChainStatesContext.Provider, { value: provided, children: children });\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}