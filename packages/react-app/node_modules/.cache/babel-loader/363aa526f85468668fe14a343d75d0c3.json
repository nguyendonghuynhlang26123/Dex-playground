{"ast":null,"code":"import { useContext, useEffect, useMemo } from 'react';\nimport { MultiChainStatesContext } from '../providers';\nimport { useEthers } from './useEthers';\n/**\n * A low-level function that makes multiple calls to specific methods of specific contracts and returns values or error if present.\n * The hook will cause the component to refresh when values change.\n *\n * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.\n * It is recommended to use useCalls where applicable instead of this method.\n * @param calls List of calls, also see {@link ChainCall}. Calls need to be in the same order across component renders.\n * @returns\n */\n\nexport function useRawCalls(calls) {\n  const {\n    dispatchCalls,\n    chains\n  } = useContext(MultiChainStatesContext);\n  const {\n    chainId\n  } = useEthers();\n  useEffect(() => {\n    const filteredCalls = calls.filter(Boolean);\n    dispatchCalls({\n      type: 'ADD_CALLS',\n      calls: filteredCalls\n    });\n    return () => dispatchCalls({\n      type: 'REMOVE_CALLS',\n      calls: filteredCalls\n    });\n  }, [JSON.stringify(calls), dispatchCalls]);\n  return useMemo(() => calls.map(call => {\n    return call ? extractCallResult(chains, call, chainId) : undefined;\n  }), [JSON.stringify(calls), chains]);\n}\n/**\n * A low-level function that makes a call to a specific method of a specific contract and returns the value or error if present.\n * The hook will cause the component to refresh whenever a new block is mined and the value is changed.\n *\n * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.\n * It is recommended to use useCall where applicable instead of this method.\n *\n * @param call a single call, also see {@link RawCall}.\n *             A call can be Falsy, as it is important to keep the same ordering of hooks even if in a given render cycle\n *             and there might be not enough information to perform a call.\n * @returns result of multicall call.\n */\n\nexport function useRawCall(call) {\n  return useRawCalls([call])[0];\n}\n\nfunction extractCallResult(chains, call, defaultChainId) {\n  var _a, _b, _c, _d, _e;\n\n  const chainId = (_a = call.chainId) !== null && _a !== void 0 ? _a : defaultChainId;\n  return chainId !== undefined ? (_e = (_d = (_c = (_b = chains[chainId]) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d[call.address]) === null || _e === void 0 ? void 0 : _e[call.data] : undefined;\n}","map":{"version":3,"sources":["../../../../src/hooks/useRawCalls.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,EAAqB,SAArB,EAAgC,OAAhC,QAA+C,OAA/C;AACA,SAAS,uBAAT,QAAuD,cAAvD;AAIA,SAAS,SAAT,QAA0B,aAA1B;AAEA;;;;;;;;AAQG;;AACH,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAgD;AACpD,QAAM;AAAE,IAAA,aAAF;AAAiB,IAAA;AAAjB,MAA4B,UAAU,CAAC,uBAAD,CAA5C;AACA,QAAM;AAAE,IAAA;AAAF,MAAc,SAAS,EAA7B;AAEA,EAAA,SAAS,CAAC,MAAK;AACb,UAAM,aAAa,GAAG,KAAK,CAAC,MAAN,CAAa,OAAb,CAAtB;AACA,IAAA,aAAa,CAAC;AAAE,MAAA,IAAI,EAAE,WAAR;AAAqB,MAAA,KAAK,EAAE;AAA5B,KAAD,CAAb;AACA,WAAO,MAAM,aAAa,CAAC;AAAE,MAAA,IAAI,EAAE,cAAR;AAAwB,MAAA,KAAK,EAAE;AAA/B,KAAD,CAA1B;AACD,GAJQ,EAIN,CAAC,IAAI,CAAC,SAAL,CAAe,KAAf,CAAD,EAAwB,aAAxB,CAJM,CAAT;AAMA,SAAO,OAAO,CACZ,MACE,KAAK,CAAC,GAAN,CAAW,IAAD,IAAS;AACjB,WAAO,IAAI,GAAG,iBAAiB,CAAC,MAAD,EAAS,IAAT,EAAe,OAAf,CAApB,GAA8C,SAAzD;AACD,GAFD,CAFU,EAKZ,CAAC,IAAI,CAAC,SAAL,CAAe,KAAf,CAAD,EAAwB,MAAxB,CALY,CAAd;AAOD;AAED;;;;;;;;;;;AAWG;;AACH,OAAM,SAAU,UAAV,CAAqB,IAArB,EAA0C;AAC9C,SAAO,WAAW,CAAC,CAAC,IAAD,CAAD,CAAX,CAAoB,CAApB,CAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,MAA3B,EAAoD,IAApD,EAAmE,cAAnE,EAAqG;;;AACnG,QAAM,OAAO,GAAG,CAAA,EAAA,GAAA,IAAI,CAAC,OAAL,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,EAAZ,GAAgB,cAAhC;AACA,SAAO,OAAO,KAAK,SAAZ,GAAwB,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,CAAC,OAAD,CAAN,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,KAAjB,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,KAAxB,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,KAAA,CAA7B,GAA6B,EAAA,CAAG,IAAI,CAAC,OAAR,CAA7B,MAA6C,IAA7C,IAA6C,EAAA,KAAA,KAAA,CAA7C,GAA6C,KAAA,CAA7C,GAA6C,EAAA,CAAG,IAAI,CAAC,IAAR,CAArE,GAAqF,SAA5F;AACD","sourceRoot":"","sourcesContent":["import { useContext, useEffect, useMemo } from 'react';\nimport { MultiChainStatesContext } from '../providers';\nimport { useEthers } from './useEthers';\n/**\n * A low-level function that makes multiple calls to specific methods of specific contracts and returns values or error if present.\n * The hook will cause the component to refresh when values change.\n *\n * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.\n * It is recommended to use useCalls where applicable instead of this method.\n * @param calls List of calls, also see {@link ChainCall}. Calls need to be in the same order across component renders.\n * @returns\n */\nexport function useRawCalls(calls) {\n    const { dispatchCalls, chains } = useContext(MultiChainStatesContext);\n    const { chainId } = useEthers();\n    useEffect(() => {\n        const filteredCalls = calls.filter(Boolean);\n        dispatchCalls({ type: 'ADD_CALLS', calls: filteredCalls });\n        return () => dispatchCalls({ type: 'REMOVE_CALLS', calls: filteredCalls });\n    }, [JSON.stringify(calls), dispatchCalls]);\n    return useMemo(() => calls.map((call) => {\n        return call ? extractCallResult(chains, call, chainId) : undefined;\n    }), [JSON.stringify(calls), chains]);\n}\n/**\n * A low-level function that makes a call to a specific method of a specific contract and returns the value or error if present.\n * The hook will cause the component to refresh whenever a new block is mined and the value is changed.\n *\n * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.\n * It is recommended to use useCall where applicable instead of this method.\n *\n * @param call a single call, also see {@link RawCall}.\n *             A call can be Falsy, as it is important to keep the same ordering of hooks even if in a given render cycle\n *             and there might be not enough information to perform a call.\n * @returns result of multicall call.\n */\nexport function useRawCall(call) {\n    return useRawCalls([call])[0];\n}\nfunction extractCallResult(chains, call, defaultChainId) {\n    var _a, _b, _c, _d, _e;\n    const chainId = (_a = call.chainId) !== null && _a !== void 0 ? _a : defaultChainId;\n    return chainId !== undefined ? (_e = (_d = (_c = (_b = chains[chainId]) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d[call.address]) === null || _e === void 0 ? void 0 : _e[call.data] : undefined;\n}\n//# sourceMappingURL=useRawCalls.js.map"]},"metadata":{},"sourceType":"module"}